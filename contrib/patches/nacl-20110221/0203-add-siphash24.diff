diff -Nur nacl-20110221.orig/crypto_auth/siphash24/checksum nacl-20110221/crypto_auth/siphash24/checksum
--- nacl-20110221.orig/crypto_auth/siphash24/checksum	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/checksum	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1 @@
+a64a85e731ab34e4
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/description nacl-20110221/crypto_auth/siphash24/description
--- nacl-20110221.orig/crypto_auth/siphash24/description	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/description	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1 @@
+SipHash-2-4 with a 128-bit key and 64-bit output
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/designers nacl-20110221/crypto_auth/siphash24/designers
--- nacl-20110221.orig/crypto_auth/siphash24/designers	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/designers	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,2 @@
+Jean-Philippe Aumasson
+Daniel J. Bernstein
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/little/api.h nacl-20110221/crypto_auth/siphash24/little/api.h
--- nacl-20110221.orig/crypto_auth/siphash24/little/api.h	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/little/api.h	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,3 @@
+#define CRYPTO_BYTES 8
+#define CRYPTO_KEYBYTES 16
+
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/little/implementors nacl-20110221/crypto_auth/siphash24/little/implementors
--- nacl-20110221.orig/crypto_auth/siphash24/little/implementors	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/little/implementors	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1 @@
+Samuel Neves
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/little/siphash.c nacl-20110221/crypto_auth/siphash24/little/siphash.c
--- nacl-20110221.orig/crypto_auth/siphash24/little/siphash.c	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/little/siphash.c	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,217 @@
+#include <stdlib.h>
+
+#include "crypto_auth.h"
+#include "crypto_uint64.h"
+#include "crypto_uint32.h"
+#include "crypto_uint8.h"
+#include "crypto_verify_8.h"
+
+typedef crypto_uint64 u64;
+typedef crypto_uint32 u32;
+typedef crypto_uint8 u8;
+
+#define SIPHASH_ROUNDS 2
+#define SIPHASH_FINALROUNDS 4
+
+/*
+typedef  uint8_t  u8;
+typedef uint32_t u32;
+typedef uint64_t u64;
+*/
+
+#define rotl64(x, c) ( ((x) << (c)) ^ ((x) >> (64-(c))) )
+
+static u64 siphash(const u8 key[16], const unsigned char *m, const u64 n)
+{
+	u64 v0, v1, v2, v3;
+	u64 k0, k1;
+	u64 mi, mask, len;
+	size_t i, k;
+
+	k0 = *((u64*)(key + 0));
+	k1 = *((u64*)(key + 8));
+
+	v0 = k0 ^ 0x736f6d6570736575ULL;
+	v1 = k1 ^ 0x646f72616e646f6dULL;
+	v2 = k0 ^ 0x6c7967656e657261ULL;
+	v3 = k1 ^ 0x7465646279746573ULL;
+
+#define HALF_ROUND(a,b,c,d,s,t) \
+	do \
+	{ \
+		a += b;  c += d; \
+		b = rotl64(b, s); d = rotl64(d, t); \
+		b ^= a;  d ^= c; \
+	} while(0)
+
+#define COMPRESS(v0,v1,v2,v3) \
+	do \
+	{ \
+		HALF_ROUND(v0,v1,v2,v3,13,16); \
+		v0 = rotl64(v0,32); \
+		HALF_ROUND(v2,v1,v0,v3,17,21); \
+		v2 = rotl64(v2, 32); \
+	} while(0)
+
+	for(i = 0; i < (n-n%8); i += 8)
+	{
+		mi = *((u64*)(m + i));
+		v3 ^= mi;
+		for(k = 0; k < SIPHASH_ROUNDS; ++k) COMPRESS(v0,v1,v2,v3);
+		v0 ^= mi;
+	}
+
+	mi = *((u64*)(m + i));
+	len = (n&0xff) << 56;
+	mask = n%8 == 0 ? 0 : 0xffffffffffffffffULL >> (8*(8-n%8));
+	mi = (mi&mask) ^ len;
+
+	v3 ^= mi;
+	for(k = 0; k < SIPHASH_ROUNDS; ++k) COMPRESS(v0,v1,v2,v3);
+	v0 ^= mi;
+	
+	v2 ^= 0xff;
+	for(k = 0; k < SIPHASH_FINALROUNDS; ++k) COMPRESS(v0,v1,v2,v3);
+
+#undef COMPRESS
+#undef HALF_ROUND
+	return (v0 ^ v1) ^ (v2 ^ v3);
+}
+
+int crypto_auth(unsigned char *out,const unsigned char *in,unsigned long long inlen,const unsigned char *k)
+{
+  int i;
+  union
+  {
+    u8  bytes[8];
+    u64 gpr;
+  } hash;
+  hash.gpr = siphash(k, in, inlen);
+  for(i=0; i < 8; ++i) out[i] = hash.bytes[i];
+  return 0;
+}
+
+
+int crypto_auth_verify(const unsigned char *h,const unsigned char *in,unsigned long long inlen,const unsigned char *k)
+{
+  u8 correct[8];
+  crypto_auth(correct,in,inlen,k);
+  return crypto_verify_8(h,correct);
+}
+
+
+#if 0
+/*
+   SipHash-2-4 output with
+   k = 00 01 02 ...
+   and
+   in = (empty string)
+   in = 00 (1 byte)
+   in = 00 01 (2 bytes)
+   in = 00 01 02 (3 bytes)
+   ...
+   in = 00 01 02 ... 3e (63 bytes)
+*/
+u8 vectors[64][8] =
+{
+  { 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, },
+  { 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, },
+  { 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, },
+  { 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, },
+  { 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, },
+  { 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, },
+  { 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, },
+  { 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, },
+  { 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, },
+  { 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, },
+  { 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, },
+  { 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, },
+  { 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, },
+  { 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, },
+  { 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, },
+  { 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, },
+  { 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, },
+  { 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, },
+  { 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, },
+  { 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, },
+  { 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, },
+  { 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, },
+  { 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, },
+  { 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, },
+  { 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, },
+  { 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, },
+  { 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, },
+  { 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, },
+  { 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, },
+  { 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, },
+  { 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, },
+  { 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, },
+  { 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, },
+  { 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, },
+  { 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, },
+  { 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, },
+  { 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, },
+  { 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, },
+  { 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, },
+  { 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, },
+  { 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, },
+  { 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, },
+  { 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, },
+  { 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, },
+  { 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, },
+  { 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, },
+  { 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, },
+  { 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, },
+  { 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, },
+  { 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, },
+  { 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, },
+  { 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, },
+  { 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, },
+  { 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, },
+  { 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, },
+  { 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, },
+  { 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, },
+  { 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, },
+  { 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, },
+  { 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, },
+  { 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, },
+  { 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, },
+  { 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, },
+  { 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, }
+};
+
+
+int test_vectors()
+{
+#define MAXLEN 64
+  u8 in[MAXLEN], out[8], k[16];
+  int i;
+  int ok = 1;
+
+  for( i = 0; i < 16; ++i ) k[i] = i;
+
+  for( i = 0; i < MAXLEN; ++i )
+  {
+    in[i] = i;
+    crypto_auth( out, in, i, k );
+
+    if ( memcmp( out, vectors[i], 8 ) )
+    {
+      printf( "test vector failed for %d bytes\n", i );
+      ok = 0;
+    }
+  }
+
+  return ok;
+}
+
+int main()
+{
+  if ( test_vectors() ) printf( "test vectors ok\n" );
+
+  return 0;
+}
+
+
+#endif
+
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/little2/api.h nacl-20110221/crypto_auth/siphash24/little2/api.h
--- nacl-20110221.orig/crypto_auth/siphash24/little2/api.h	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/little2/api.h	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,2 @@
+#define CRYPTO_BYTES 8
+#define CRYPTO_KEYBYTES 16
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/little2/implementors nacl-20110221/crypto_auth/siphash24/little2/implementors
--- nacl-20110221.orig/crypto_auth/siphash24/little2/implementors	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/little2/implementors	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1 @@
+Daniel J. Bernstein
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/little2/siphash.c nacl-20110221/crypto_auth/siphash24/little2/siphash.c
--- nacl-20110221.orig/crypto_auth/siphash24/little2/siphash.c	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/little2/siphash.c	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,55 @@
+#include "crypto_auth.h"
+#include "crypto_uint64.h"
+typedef crypto_uint64 uint64;
+
+#define ROTATE(x,b) x = (x << b) | (x >> (64 - b))
+
+#define ROUND \
+  v0 += v1; v2 += v3; \
+  ROTATE(v1,13); ROTATE(v3,16); \
+  v1 ^= v0; v3 ^= v2; \
+  ROTATE(v0,32); \
+  v2 += v1; v0 += v3; \
+  ROTATE(v1,17); ROTATE(v3,21); \
+  v1 ^= v2; v3 ^= v0; \
+  ROTATE(v2,32);
+
+int crypto_auth(unsigned char *out,const unsigned char *in,unsigned long long inlen,const unsigned char *k)
+{
+  uint64 v0 = *(uint64 *) (k);
+  uint64 v1 = *(uint64 *) (k + 8);
+  uint64 lastblock = inlen << 56;
+  uint64 v2 = v0;
+  uint64 v3 = v1;
+  int i;
+
+  v0 ^= 0x736f6d6570736575;
+  v1 ^= 0x646f72616e646f6d;
+  v2 ^= 0x6c7967656e657261;
+  v3 ^= 0x7465646279746573;
+
+  while (inlen >= 8) { /* floor(inlen/8) normal loops */
+    uint64 mi = *(uint64 *) in;
+    in += 8;
+    v3 ^= mi;
+    ROUND
+    ROUND
+    v0 ^= mi;
+    inlen -= 8;
+  }
+  /* now inlen <= 7; 1 extra loop; total loops: ceil((inlen+1)/8) */
+  for (i = 0;i < inlen;++i) i[(char *) &lastblock] = i[in];
+  v3 ^= lastblock;
+  ROUND
+  ROUND
+  v0 ^= lastblock;
+
+  v2 ^= 0xff;
+  ROUND
+  ROUND
+  ROUND
+  ROUND
+  *(uint64 *) out = (v0 ^ v1) ^ (v2 ^ v3);
+
+  return 0;
+}
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/little2/verify.c nacl-20110221/crypto_auth/siphash24/little2/verify.c
--- nacl-20110221.orig/crypto_auth/siphash24/little2/verify.c	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/little2/verify.c	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,9 @@
+#include "crypto_auth.h"
+#include "crypto_verify_8.h"
+
+int crypto_auth_verify(const unsigned char *h,const unsigned char *in,unsigned long long inlen,const unsigned char *k)
+{
+  unsigned char correct[8];
+  crypto_auth(correct,in,inlen,k);
+  return crypto_verify_8(h,correct);
+}
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/mmx/api.h nacl-20110221/crypto_auth/siphash24/mmx/api.h
--- nacl-20110221.orig/crypto_auth/siphash24/mmx/api.h	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/mmx/api.h	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,3 @@
+#define CRYPTO_BYTES 8
+#define CRYPTO_KEYBYTES 16
+
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/mmx/architectures nacl-20110221/crypto_auth/siphash24/mmx/architectures
--- nacl-20110221.orig/crypto_auth/siphash24/mmx/architectures	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/mmx/architectures	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,2 @@
+x86
+amd64
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/mmx/implementors nacl-20110221/crypto_auth/siphash24/mmx/implementors
--- nacl-20110221.orig/crypto_auth/siphash24/mmx/implementors	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/mmx/implementors	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1 @@
+Samuel Neves
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/mmx/siphash.c nacl-20110221/crypto_auth/siphash24/mmx/siphash.c
--- nacl-20110221.orig/crypto_auth/siphash24/mmx/siphash.c	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/mmx/siphash.c	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,225 @@
+#include <mmintrin.h>
+#include <emmintrin.h>
+
+#include "crypto_auth.h"
+#include "crypto_uint64.h"
+#include "crypto_uint32.h"
+#include "crypto_uint8.h"
+#include "crypto_verify_8.h"
+
+typedef crypto_uint64 u64;
+typedef crypto_uint32 u32;
+typedef crypto_uint8 u8;
+
+#define SIPHASH_ROUNDS 2
+#define SIPHASH_FINALROUNDS 4
+
+/*
+typedef  uint8_t  u8;
+typedef uint32_t u32;
+typedef uint64_t u64;
+*/
+
+#define _mm_roti_si64(x, c) ((16 == (c)) ? _mm_shuffle_pi16((x), _MM_SHUFFLE(2,1,0,3)) : _mm_xor_si64(_mm_slli_si64((x), (c)), _mm_srli_si64((x), 64-(c))))
+
+static u64 siphash(const u8 key[16], const unsigned char *m, const u64 n)
+{
+	__m64 v0, v1, v2, v3;
+	__m64 k0, k1;
+	__m64 mi, mask, len;
+        union
+        {
+	  u64   gpr;
+          __m64 mmx;
+        } hash;
+	size_t i, k;
+
+	k0 = *((__m64*)(key + 0));
+	k1 = *((__m64*)(key + 8));
+
+	v0 = _mm_xor_si64(k0, _mm_set_pi32(0x736f6d65, 0x70736575));
+	v1 = _mm_xor_si64(k1, _mm_set_pi32(0x646f7261, 0x6e646f6d));
+	v2 = _mm_xor_si64(k0, _mm_set_pi32(0x6c796765, 0x6e657261));
+	v3 = _mm_xor_si64(k1, _mm_set_pi32(0x74656462, 0x79746573));
+
+#define HALF_ROUND(a,b,c,d,s,t) \
+	do \
+	{ \
+		a = _mm_add_si64(a, b);  c = _mm_add_si64(c, d); \
+		b = _mm_roti_si64(b, s); d = _mm_roti_si64(d, t); \
+		b = _mm_xor_si64(b, a);  d = _mm_xor_si64(d, c); \
+	} while(0)
+
+#define COMPRESS(v0,v1,v2,v3) \
+	do \
+	{ \
+		HALF_ROUND(v0,v1,v2,v3,13,16); \
+		v0 = _mm_shuffle_pi16(v0, _MM_SHUFFLE(1,0,3,2)); \
+		HALF_ROUND(v2,v1,v0,v3,17,21); \
+		v2 = _mm_shuffle_pi16(v2, _MM_SHUFFLE(1,0,3,2)); \
+	} while(0)
+
+	for(i = 0; i < (n-n%8); i += 8)
+	{
+		mi = *((__m64*)(m + i));
+		v3 = _mm_xor_si64(v3, mi);
+		for(k = 0; k < SIPHASH_ROUNDS; ++k) COMPRESS(v0,v1,v2,v3);
+		v0 = _mm_xor_si64(v0, mi);
+	}
+
+	mi = *((__m64*)(m + i));
+	len = _mm_set_pi32((n&0xff) << 24, 0);
+	mask = _mm_srli_si64(_mm_set_pi32(0xffffffff, 0xffffffff), 8*(8-n%8));
+	mi = _mm_xor_si64(_mm_and_si64(mi, mask), len);
+
+	v3 = _mm_xor_si64(v3, mi);
+	for(k = 0; k < SIPHASH_ROUNDS; ++k) COMPRESS(v0,v1,v2,v3);
+	v0 = _mm_xor_si64(v0, mi);
+	
+	v2 = _mm_xor_si64(v2, _mm_set_pi32(0, 0xff));
+	for(k = 0; k < SIPHASH_FINALROUNDS; ++k) COMPRESS(v0,v1,v2,v3);
+
+	hash.mmx = _mm_xor_si64(_mm_xor_si64(v0, v1), _mm_xor_si64(v2, v3));
+
+#undef COMPRESS
+#undef HALF_ROUND
+	_mm_empty();
+
+	return hash.gpr;
+}
+
+int crypto_auth(unsigned char *out,const unsigned char *in,unsigned long long inlen,const unsigned char *k)
+{
+  int i;
+  union
+  {
+    u8  bytes[8];
+    u64 gpr;
+  } hash;
+  hash.gpr = siphash(k, in, inlen);
+  for(i=0; i < 8; ++i) out[i] = hash.bytes[i];
+  return 0;
+}
+
+
+int crypto_auth_verify(const unsigned char *h,const unsigned char *in,unsigned long long inlen,const unsigned char *k)
+{
+  u8 correct[8];
+  crypto_auth(correct,in,inlen,k);
+  return crypto_verify_8(h,correct);
+}
+
+#if 0
+/*
+   SipHash-2-4 output with
+   k = 00 01 02 ...
+   and
+   in = (empty string)
+   in = 00 (1 byte)
+   in = 00 01 (2 bytes)
+   in = 00 01 02 (3 bytes)
+   ...
+   in = 00 01 02 ... 3e (63 bytes)
+*/
+u8 vectors[64][8] =
+{
+  { 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, },
+  { 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, },
+  { 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, },
+  { 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, },
+  { 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, },
+  { 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, },
+  { 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, },
+  { 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, },
+  { 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, },
+  { 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, },
+  { 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, },
+  { 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, },
+  { 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, },
+  { 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, },
+  { 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, },
+  { 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, },
+  { 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, },
+  { 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, },
+  { 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, },
+  { 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, },
+  { 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, },
+  { 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, },
+  { 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, },
+  { 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, },
+  { 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, },
+  { 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, },
+  { 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, },
+  { 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, },
+  { 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, },
+  { 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, },
+  { 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, },
+  { 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, },
+  { 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, },
+  { 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, },
+  { 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, },
+  { 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, },
+  { 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, },
+  { 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, },
+  { 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, },
+  { 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, },
+  { 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, },
+  { 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, },
+  { 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, },
+  { 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, },
+  { 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, },
+  { 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, },
+  { 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, },
+  { 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, },
+  { 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, },
+  { 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, },
+  { 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, },
+  { 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, },
+  { 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, },
+  { 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, },
+  { 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, },
+  { 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, },
+  { 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, },
+  { 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, },
+  { 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, },
+  { 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, },
+  { 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, },
+  { 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, },
+  { 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, },
+  { 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, }
+};
+
+
+int test_vectors()
+{
+#define MAXLEN 64
+  u8 in[MAXLEN], out[8], k[16];
+  int i;
+  int ok = 1;
+
+  for( i = 0; i < 16; ++i ) k[i] = i;
+
+  for( i = 0; i < MAXLEN; ++i )
+  {
+    in[i] = i;
+    crypto_auth( out, in, i, k );
+
+    if ( memcmp( out, vectors[i], 8 ) )
+    {
+      printf( "test vector failed for %d bytes\n", i );
+      ok = 0;
+    }
+  }
+
+  return ok;
+}
+
+int main()
+{
+  if ( test_vectors() ) printf( "test vectors ok\n" );
+
+  return 0;
+}
+
+#endif
+
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/ref_le/api.h nacl-20110221/crypto_auth/siphash24/ref_le/api.h
--- nacl-20110221.orig/crypto_auth/siphash24/ref_le/api.h	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/ref_le/api.h	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,2 @@
+#define CRYPTO_BYTES 8
+#define CRYPTO_KEYBYTES 16
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/ref_le/implementors nacl-20110221/crypto_auth/siphash24/ref_le/implementors
--- nacl-20110221.orig/crypto_auth/siphash24/ref_le/implementors	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/ref_le/implementors	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1 @@
+Jean-Philippe Aumasson
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/ref_le/siphash.c nacl-20110221/crypto_auth/siphash24/ref_le/siphash.c
--- nacl-20110221.orig/crypto_auth/siphash24/ref_le/siphash.c	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/ref_le/siphash.c	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,96 @@
+#include "crypto_auth.h"
+#include "crypto_uint64.h"
+#include "crypto_uint32.h"
+#include "crypto_uint8.h"
+
+typedef crypto_uint64 u64;
+typedef crypto_uint32 u32;
+typedef crypto_uint8   u8;
+
+#define ROTL(x,b) (u64)( ((x) << (b)) | ( (x) >> (64 - (b))) )
+
+#define U32TO8_LE(p, v)         \
+    (p)[0] = (u8)((v)      ); (p)[1] = (u8)((v) >>  8); \
+    (p)[2] = (u8)((v) >> 16); (p)[3] = (u8)((v) >> 24);
+
+#define U64TO8_LE(p, v)         \
+    U32TO8_LE((p),     (u32)((v)      ));   \
+    U32TO8_LE((p) + 4, (u32)((v) >> 32));
+
+#define SIPROUND            \
+  do {              \
+    x0 += x1; x1=ROTL(x1,13); x1 ^= x0; x0=ROTL(x0,32); \
+    x2 += x3; x3=ROTL(x3,16); x3 ^= x2;     \
+    x0 += x3; x3=ROTL(x3,21); x3 ^= x0;     \
+    x2 += x1; x1=ROTL(x1,17); x1 ^= x2; x2=ROTL(x2,32); \
+  } while(0)
+
+
+int crypto_auth( unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *k )
+{
+  u64 h;
+  /* "somepseudorandomlygeneratedbytes" */
+  u64 x0 = 0x736f6d6570736575ULL;
+  u64 x1 = 0x646f72616e646f6dULL;
+  u64 x2 = 0x6c7967656e657261ULL;
+  u64 x3 = 0x7465646279746573ULL;
+  u64 b;
+  /* little-endian only */
+  u64 k0 = ( ( u64 * )k )[0];
+  u64 k1 = ( ( u64 * )k )[1];
+  union
+  {
+    const u8 *v8;
+    u32     *v32;
+    u64     *v64;
+  } m;
+  m.v8 = ( const u8 * )in;
+  const u64 *end = m.v64 + ( ( inlen >> 3 ) );
+  const int left = inlen & 7;
+  b = ( ( u64 )inlen ) << 56;
+  x3 ^= k1;
+  x2 ^= k0;
+  x1 ^= k1;
+  x0 ^= k0;
+
+  for( ; m.v64 < end; m.v64++ )
+  {
+    x3 ^= m.v64[0];
+    SIPROUND;
+    SIPROUND;
+    x0 ^= m.v64[0];
+  }
+
+  switch( left )
+  {
+  case 7: b |= ( ( u64 )m.v8[ 6] )  << 48;
+
+  case 6: b |= ( ( u64 )m.v8[ 5] )  << 40;
+
+  case 5: b |= ( ( u64 )m.v8[ 4] )  << 32;
+
+  case 4: b |= ( ( u64 )m.v32[0] ); break;
+
+  case 3: b |= ( ( u64 )m.v8[ 2] )  << 16;
+
+  case 2: b |= ( ( u64 )m.v8[ 1] )  <<  8;
+
+  case 1: b |= ( ( u64 )m.v8[ 0] ); break;
+
+  case 0: break;
+  }
+
+  x3 ^= b;
+  SIPROUND;
+  SIPROUND;
+  x0 ^= b;
+  x2 ^= 0xff;
+  SIPROUND;
+  SIPROUND;
+  SIPROUND;
+  SIPROUND;
+  /* make non-portable to be faster on short data */
+  ( ( u64 * )out )[0] = x0 ^ x1 ^ x2 ^ x3;
+  return 0;
+}
+
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/ref_le/verify.c nacl-20110221/crypto_auth/siphash24/ref_le/verify.c
--- nacl-20110221.orig/crypto_auth/siphash24/ref_le/verify.c	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/ref_le/verify.c	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,9 @@
+#include "crypto_auth.h"
+#include "crypto_verify_8.h"
+
+int crypto_auth_verify( const unsigned char *h, const unsigned char *in, unsigned long long inlen, const unsigned char *k )
+{
+  unsigned char correct[8];
+  crypto_auth( correct, in, inlen, k );
+  return crypto_verify_8( h, correct );
+}
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/sandy/api.h nacl-20110221/crypto_auth/siphash24/sandy/api.h
--- nacl-20110221.orig/crypto_auth/siphash24/sandy/api.h	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/sandy/api.h	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,3 @@
+#define CRYPTO_BYTES 8
+#define CRYPTO_KEYBYTES 16
+
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/sandy/implementors nacl-20110221/crypto_auth/siphash24/sandy/implementors
--- nacl-20110221.orig/crypto_auth/siphash24/sandy/implementors	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/sandy/implementors	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1 @@
+based on: little
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/sandy/siphash.c nacl-20110221/crypto_auth/siphash24/sandy/siphash.c
--- nacl-20110221.orig/crypto_auth/siphash24/sandy/siphash.c	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/sandy/siphash.c	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,223 @@
+#include <stdlib.h>
+
+#include "crypto_auth.h"
+#include "crypto_uint64.h"
+#include "crypto_uint32.h"
+#include "crypto_uint8.h"
+#include "crypto_verify_8.h"
+
+typedef crypto_uint64 u64;
+typedef crypto_uint32 u32;
+typedef crypto_uint8 u8;
+
+#define SIPHASH_ROUNDS 2
+#define SIPHASH_FINALROUNDS 4
+
+/*
+typedef  uint8_t  u8;
+typedef uint32_t u32;
+typedef uint64_t u64;
+*/
+
+#define ROT(x,n) ({ \
+     register u64 __out; \
+     register u64 __in = x; \
+     __asm__ ("shld %2,%0,%0" : "=r"(__out) : "0"(__in), "i"(n)); \
+     __out; \
+  })
+
+#define rotl64(x, c) ROT(x,c)
+
+static u64 siphash(const u8 key[16], const unsigned char *m, const u64 n)
+{
+	u64 v0, v1, v2, v3;
+	u64 k0, k1;
+	u64 mi, mask, len;
+	size_t i, k;
+
+	k0 = *((u64*)(key + 0));
+	k1 = *((u64*)(key + 8));
+
+	v0 = k0 ^ 0x736f6d6570736575ULL;
+	v1 = k1 ^ 0x646f72616e646f6dULL;
+	v2 = k0 ^ 0x6c7967656e657261ULL;
+	v3 = k1 ^ 0x7465646279746573ULL;
+
+#define HALF_ROUND(a,b,c,d,s,t) \
+	do \
+	{ \
+		a += b;  c += d; \
+		b = rotl64(b, s); d = rotl64(d, t); \
+		b ^= a;  d ^= c; \
+	} while(0)
+
+#define COMPRESS(v0,v1,v2,v3) \
+	do \
+	{ \
+		HALF_ROUND(v0,v1,v2,v3,13,16); \
+		v0 = rotl64(v0,32); \
+		HALF_ROUND(v2,v1,v0,v3,17,21); \
+		v2 = rotl64(v2, 32); \
+	} while(0)
+
+	for(i = 0; i < (n-n%8); i += 8)
+	{
+		mi = *((u64*)(m + i));
+		v3 ^= mi;
+		for(k = 0; k < SIPHASH_ROUNDS; ++k) COMPRESS(v0,v1,v2,v3);
+		v0 ^= mi;
+	}
+
+	mi = *((u64*)(m + i));
+	len = (n&0xff) << 56;
+	mask = n%8 == 0 ? 0 : 0xffffffffffffffffULL >> (8*(8-n%8));
+	mi = (mi&mask) ^ len;
+
+	v3 ^= mi;
+	for(k = 0; k < SIPHASH_ROUNDS; ++k) COMPRESS(v0,v1,v2,v3);
+	v0 ^= mi;
+	
+	v2 ^= 0xff;
+	for(k = 0; k < SIPHASH_FINALROUNDS; ++k) COMPRESS(v0,v1,v2,v3);
+
+#undef COMPRESS
+#undef HALF_ROUND
+	return (v0 ^ v1) ^ (v2 ^ v3);
+}
+
+int crypto_auth(unsigned char *out,const unsigned char *in,unsigned long long inlen,const unsigned char *k)
+{
+  int i;
+  union
+  {
+    u8  bytes[8];
+    u64 gpr;
+  } hash;
+  hash.gpr = siphash(k, in, inlen);
+  for(i=0; i < 8; ++i) out[i] = hash.bytes[i];
+  return 0;
+}
+
+int crypto_auth_verify(const unsigned char *h,const unsigned char *in,unsigned long long inlen,const unsigned char *k)
+{
+  u8 correct[8];
+  crypto_auth(correct,in,inlen,k);
+  return crypto_verify_8(h,correct);
+}
+
+
+#if 0
+/*
+   SipHash-2-4 output with
+   k = 00 01 02 ...
+   and
+   in = (empty string)
+   in = 00 (1 byte)
+   in = 00 01 (2 bytes)
+   in = 00 01 02 (3 bytes)
+   ...
+   in = 00 01 02 ... 3e (63 bytes)
+*/
+u8 vectors[64][8] =
+{
+  { 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, },
+  { 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, },
+  { 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, },
+  { 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, },
+  { 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, },
+  { 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, },
+  { 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, },
+  { 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, },
+  { 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, },
+  { 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, },
+  { 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, },
+  { 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, },
+  { 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, },
+  { 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, },
+  { 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, },
+  { 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, },
+  { 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, },
+  { 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, },
+  { 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, },
+  { 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, },
+  { 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, },
+  { 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, },
+  { 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, },
+  { 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, },
+  { 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, },
+  { 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, },
+  { 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, },
+  { 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, },
+  { 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, },
+  { 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, },
+  { 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, },
+  { 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, },
+  { 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, },
+  { 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, },
+  { 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, },
+  { 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, },
+  { 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, },
+  { 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, },
+  { 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, },
+  { 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, },
+  { 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, },
+  { 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, },
+  { 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, },
+  { 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, },
+  { 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, },
+  { 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, },
+  { 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, },
+  { 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, },
+  { 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, },
+  { 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, },
+  { 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, },
+  { 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, },
+  { 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, },
+  { 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, },
+  { 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, },
+  { 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, },
+  { 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, },
+  { 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, },
+  { 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, },
+  { 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, },
+  { 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, },
+  { 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, },
+  { 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, },
+  { 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, }
+};
+
+
+int test_vectors()
+{
+#define MAXLEN 64
+  u8 in[MAXLEN], out[8], k[16];
+  int i;
+  int ok = 1;
+
+  for( i = 0; i < 16; ++i ) k[i] = i;
+
+  for( i = 0; i < MAXLEN; ++i )
+  {
+    in[i] = i;
+    crypto_auth( out, in, i, k );
+
+    if ( memcmp( out, vectors[i], 8 ) )
+    {
+      printf( "test vector failed for %d bytes\n", i );
+      ok = 0;
+    }
+  }
+
+  return ok;
+}
+
+int main()
+{
+  if ( test_vectors() ) printf( "test vectors ok\n" );
+
+  return 0;
+}
+
+
+#endif
+
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/sandy2/api.h nacl-20110221/crypto_auth/siphash24/sandy2/api.h
--- nacl-20110221.orig/crypto_auth/siphash24/sandy2/api.h	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/sandy2/api.h	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,2 @@
+#define CRYPTO_BYTES 8
+#define CRYPTO_KEYBYTES 16
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/sandy2/implementors nacl-20110221/crypto_auth/siphash24/sandy2/implementors
--- nacl-20110221.orig/crypto_auth/siphash24/sandy2/implementors	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/sandy2/implementors	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1 @@
+Daniel J. Bernstein
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/sandy2/siphash.c nacl-20110221/crypto_auth/siphash24/sandy2/siphash.c
--- nacl-20110221.orig/crypto_auth/siphash24/sandy2/siphash.c	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/sandy2/siphash.c	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,60 @@
+#include "crypto_auth.h"
+#include "crypto_uint64.h"
+typedef crypto_uint64 uint64;
+
+#define ROTATE(x,n) ({ \
+     register uint64 __out; \
+     register uint64 __in = x; \
+     __asm__ ("shld %2,%0,%0" : "=r"(__out) : "0"(__in), "i"(n)); \
+     x = __out; \
+  })
+
+#define ROUND \
+  v0 += v1; v2 += v3; \
+  ROTATE(v1,13); ROTATE(v3,16); \
+  v1 ^= v0; v3 ^= v2; \
+  ROTATE(v0,32); \
+  v2 += v1; v0 += v3; \
+  ROTATE(v1,17); ROTATE(v3,21); \
+  v1 ^= v2; v3 ^= v0; \
+  ROTATE(v2,32);
+
+int crypto_auth(unsigned char *out,const unsigned char *in,unsigned long long inlen,const unsigned char *k)
+{
+  uint64 v0 = *(uint64 *) (k);
+  uint64 v1 = *(uint64 *) (k + 8);
+  uint64 lastblock = inlen << 56;
+  uint64 v2 = v0;
+  uint64 v3 = v1;
+  int i;
+
+  v0 ^= 0x736f6d6570736575;
+  v1 ^= 0x646f72616e646f6d;
+  v2 ^= 0x6c7967656e657261;
+  v3 ^= 0x7465646279746573;
+
+  while (inlen >= 8) { /* floor(inlen/8) normal loops */
+    uint64 mi = *(uint64 *) in;
+    in += 8;
+    v3 ^= mi;
+    ROUND
+    ROUND
+    v0 ^= mi;
+    inlen -= 8;
+  }
+  /* now inlen <= 7; 1 extra loop; total loops: ceil((inlen+1)/8) */
+  for (i = 0;i < inlen;++i) i[(char *) &lastblock] = i[in];
+  v3 ^= lastblock;
+  ROUND
+  ROUND
+  v0 ^= lastblock;
+
+  v2 ^= 0xff;
+  ROUND
+  ROUND
+  ROUND
+  ROUND
+  *(uint64 *) out = (v0 ^ v1) ^ (v2 ^ v3);
+
+  return 0;
+}
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/sandy2/verify.c nacl-20110221/crypto_auth/siphash24/sandy2/verify.c
--- nacl-20110221.orig/crypto_auth/siphash24/sandy2/verify.c	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/sandy2/verify.c	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,9 @@
+#include "crypto_auth.h"
+#include "crypto_verify_8.h"
+
+int crypto_auth_verify(const unsigned char *h,const unsigned char *in,unsigned long long inlen,const unsigned char *k)
+{
+  unsigned char correct[8];
+  crypto_auth(correct,in,inlen,k);
+  return crypto_verify_8(h,correct);
+}
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/sse2-1/api.h nacl-20110221/crypto_auth/siphash24/sse2-1/api.h
--- nacl-20110221.orig/crypto_auth/siphash24/sse2-1/api.h	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/sse2-1/api.h	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,3 @@
+#define CRYPTO_BYTES 8
+#define CRYPTO_KEYBYTES 16
+
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/sse2-1/architectures nacl-20110221/crypto_auth/siphash24/sse2-1/architectures
--- nacl-20110221.orig/crypto_auth/siphash24/sse2-1/architectures	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/sse2-1/architectures	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,2 @@
+x86
+amd64
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/sse2-1/implementors nacl-20110221/crypto_auth/siphash24/sse2-1/implementors
--- nacl-20110221.orig/crypto_auth/siphash24/sse2-1/implementors	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/sse2-1/implementors	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1 @@
+Samuel Neves
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/sse2-1/siphash.c nacl-20110221/crypto_auth/siphash24/sse2-1/siphash.c
--- nacl-20110221.orig/crypto_auth/siphash24/sse2-1/siphash.c	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/sse2-1/siphash.c	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,221 @@
+
+#include <emmintrin.h>
+#include <x86intrin.h> 
+
+#include "crypto_auth.h"
+#include "crypto_uint64.h"
+#include "crypto_uint32.h"
+#include "crypto_uint8.h"
+#include "crypto_verify_8.h"
+
+typedef crypto_uint64 u64;
+typedef crypto_uint32 u32;
+typedef crypto_uint8 u8;
+
+#define SIPHASH_ROUNDS 2
+#define SIPHASH_FINALROUNDS 4
+
+/*
+typedef  uint8_t  u8;
+typedef uint32_t u32;
+typedef uint64_t u64;
+*/
+
+#define _mm_roti_epi64(x, c) ((16 == (c)) ? _mm_shufflelo_epi16((x), _MM_SHUFFLE(2,1,0,3)) : _mm_xor_si128(_mm_slli_epi64((x), (c)), _mm_srli_epi64((x), 64-(c))))
+
+static u64 siphash(const u8 key[16], const unsigned char *m, const u64 n)
+{
+	__m128i v0, v1, v2, v3;
+	__m128i k0, k1;
+	__m128i mi, mask, len;
+	size_t i, k;
+	union { u64 gpr; __m128i xmm; } hash;
+
+	k0 = _mm_loadl_epi64((__m128i*)(key + 0));
+	k1 = _mm_loadl_epi64((__m128i*)(key + 8));
+
+	v0 = _mm_xor_si128(k0, _mm_set_epi32(0, 0, 0x736f6d65, 0x70736575));
+	v1 = _mm_xor_si128(k1, _mm_set_epi32(0, 0, 0x646f7261, 0x6e646f6d));
+	v2 = _mm_xor_si128(k0, _mm_set_epi32(0, 0, 0x6c796765, 0x6e657261));
+	v3 = _mm_xor_si128(k1, _mm_set_epi32(0, 0, 0x74656462, 0x79746573));
+
+#define HALF_ROUND(a,b,c,d,s,t) \
+	do \
+	{ \
+		a = _mm_add_epi64(a, b);  c = _mm_add_epi64(c, d); \
+		b = _mm_roti_epi64(b, s); d = _mm_roti_epi64(d, t); \
+		b = _mm_xor_si128(b, a);  d = _mm_xor_si128(d, c); \
+	} while(0)
+
+#define COMPRESS(v0,v1,v2,v3) \
+	do \
+	{ \
+		HALF_ROUND(v0,v1,v2,v3,13,16); \
+		v0 = _mm_shufflelo_epi16(v0, _MM_SHUFFLE(1,0,3,2)); \
+		HALF_ROUND(v2,v1,v0,v3,17,21); \
+		v2 = _mm_shufflelo_epi16(v2, _MM_SHUFFLE(1,0,3,2)); \
+	} while(0)
+
+	for(i = 0; i < (n-n%8); i += 8)
+	{
+		mi = _mm_loadl_epi64((__m128i*)(m + i));
+		v3 = _mm_xor_si128(v3, mi);
+		for(k = 0; k < SIPHASH_ROUNDS; ++k) COMPRESS(v0,v1,v2,v3);
+		v0 = _mm_xor_si128(v0, mi);
+	}
+
+	mi = _mm_loadl_epi64((__m128i*)(m + i)); 
+	len = _mm_set_epi32(0, 0, (n&0xff) << 24, 0);
+	mask = _mm_srli_epi64(_mm_set_epi32(0, 0, 0xffffffff, 0xffffffff), 8*(8-n%8));
+	mi = _mm_xor_si128(_mm_and_si128(mi, mask), len);
+
+	v3 = _mm_xor_si128(v3, mi);
+	for(k = 0; k < SIPHASH_ROUNDS; ++k) COMPRESS(v0,v1,v2,v3);
+	v0 = _mm_xor_si128(v0, mi);
+	
+	v2 = _mm_xor_si128(v2, _mm_set_epi32(0, 0, 0, 0xff));
+	for(k = 0; k < SIPHASH_FINALROUNDS; ++k) COMPRESS(v0,v1,v2,v3);
+
+	v0 = _mm_xor_si128(_mm_xor_si128(v0, v1), _mm_xor_si128(v2, v3));
+	hash.xmm = v0;
+
+#undef COMPRESS
+#undef HALF_ROUND
+	//return _mm_extract_epi32(v0, 0) | (((u64)_mm_extract_epi32(v0, 1)) << 32);
+	return hash.gpr;
+}
+
+int crypto_auth(unsigned char *out,const unsigned char *in,unsigned long long inlen,const unsigned char *k)
+{
+  int i;
+  union
+  {
+    u8  bytes[8];
+    u64 gpr;
+  } hash;
+  hash.gpr = siphash(k, in, inlen);
+  for(i=0; i < 8; ++i) out[i] = hash.bytes[i];
+  return 0;
+}
+
+int crypto_auth_verify(const unsigned char *h,const unsigned char *in,unsigned long long inlen,const unsigned char *k)
+{
+  u8 correct[8];
+  crypto_auth(correct,in,inlen,k);
+  return crypto_verify_8(h,correct);
+}
+
+#if 0
+/*
+   SipHash-2-4 output with
+   k = 00 01 02 ...
+   and
+   in = (empty string)
+   in = 00 (1 byte)
+   in = 00 01 (2 bytes)
+   in = 00 01 02 (3 bytes)
+   ...
+   in = 00 01 02 ... 3e (63 bytes)
+*/
+u8 vectors[64][8] =
+{
+  { 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, },
+  { 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, },
+  { 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, },
+  { 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, },
+  { 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, },
+  { 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, },
+  { 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, },
+  { 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, },
+  { 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, },
+  { 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, },
+  { 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, },
+  { 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, },
+  { 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, },
+  { 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, },
+  { 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, },
+  { 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, },
+  { 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, },
+  { 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, },
+  { 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, },
+  { 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, },
+  { 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, },
+  { 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, },
+  { 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, },
+  { 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, },
+  { 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, },
+  { 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, },
+  { 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, },
+  { 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, },
+  { 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, },
+  { 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, },
+  { 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, },
+  { 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, },
+  { 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, },
+  { 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, },
+  { 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, },
+  { 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, },
+  { 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, },
+  { 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, },
+  { 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, },
+  { 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, },
+  { 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, },
+  { 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, },
+  { 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, },
+  { 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, },
+  { 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, },
+  { 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, },
+  { 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, },
+  { 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, },
+  { 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, },
+  { 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, },
+  { 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, },
+  { 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, },
+  { 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, },
+  { 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, },
+  { 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, },
+  { 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, },
+  { 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, },
+  { 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, },
+  { 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, },
+  { 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, },
+  { 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, },
+  { 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, },
+  { 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, },
+  { 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, }
+};
+
+
+int test_vectors()
+{
+#define MAXLEN 64
+  u8 in[MAXLEN], out[8], k[16];
+  int i;
+  int ok = 1;
+
+  for( i = 0; i < 16; ++i ) k[i] = i;
+
+  for( i = 0; i < MAXLEN; ++i )
+  {
+    in[i] = i;
+    crypto_auth( out, in, i, k );
+
+    if ( memcmp( out, vectors[i], 8 ) )
+    {
+      printf( "test vector failed for %d bytes\n", i );
+      ok = 0;
+    }
+  }
+
+  return ok;
+}
+
+int main()
+{
+  if ( test_vectors() ) printf( "test vectors ok\n" );
+
+  return 0;
+}
+
+#endif
+
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/sse41/api.h nacl-20110221/crypto_auth/siphash24/sse41/api.h
--- nacl-20110221.orig/crypto_auth/siphash24/sse41/api.h	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/sse41/api.h	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,3 @@
+#define CRYPTO_BYTES 8
+#define CRYPTO_KEYBYTES 16
+
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/sse41/architectures nacl-20110221/crypto_auth/siphash24/sse41/architectures
--- nacl-20110221.orig/crypto_auth/siphash24/sse41/architectures	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/sse41/architectures	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,2 @@
+x86
+amd64
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/sse41/implementors nacl-20110221/crypto_auth/siphash24/sse41/implementors
--- nacl-20110221.orig/crypto_auth/siphash24/sse41/implementors	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/sse41/implementors	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1 @@
+Samuel Neves
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/sse41/siphash.c nacl-20110221/crypto_auth/siphash24/sse41/siphash.c
--- nacl-20110221.orig/crypto_auth/siphash24/sse41/siphash.c	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/sse41/siphash.c	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,229 @@
+
+#include <x86intrin.h>
+
+#include "crypto_auth.h"
+#include "crypto_uint64.h"
+#include "crypto_uint32.h"
+#include "crypto_uint8.h"
+#include "crypto_verify_8.h"
+
+typedef crypto_uint64 u64;
+typedef crypto_uint32 u32;
+typedef crypto_uint8 u8;
+
+
+#define SIPHASH_ROUNDS 2
+#define SIPHASH_FINALROUNDS 4
+
+/*
+typedef  uint8_t  u8;
+typedef uint32_t u32;
+typedef uint64_t u64;
+*/
+
+// Specialized for siphash, do not reuse
+#define rotate16(x) _mm_shufflehi_epi16((x), _MM_SHUFFLE(2,1,0,3))
+
+#define _mm_roti_epi64(x, c) (((c) == 16) ? rotate16((x)) : _mm_xor_si128(_mm_slli_epi64((x), (c)), _mm_srli_epi64((x), 64-(c))))
+//#define _mm_roti_epi64(x, c)  _mm_xor_si128(_mm_slli_epi64((x), (c)), _mm_srli_epi64((x), 64-(c)))
+
+
+static u64 siphash(const unsigned char key[16], const unsigned char *m, const u64 n)
+{
+	__m128i v0, v1, v02, v13;
+	__m128i k0;
+	__m128i mi, mask, len, h;
+	const __m128i zero = _mm_setzero_si128();
+	size_t i, k;
+	union { u64 gpr; __m128i xmm; } hash;
+
+	k0 = _mm_loadu_si128((__m128i*)(key + 0));
+
+	v0 = _mm_xor_si128(k0, _mm_set_epi32(0x646f7261, 0x6e646f6d, 0x736f6d65, 0x70736575));
+	v1 = _mm_xor_si128(k0, _mm_set_epi32(0x74656462, 0x79746573, 0x6c796765, 0x6e657261));
+
+	v02 = _mm_unpacklo_epi64(v0, v1);
+	v13 = _mm_unpackhi_epi64(v0, v1);
+
+#define HALF_ROUND(a,b,s,t) \
+do \
+{ \
+	__m128i b1,b2; \
+	a = _mm_add_epi64(a, b);  \
+	b1 = _mm_roti_epi64(b, s); b2 = _mm_roti_epi64(b, t); b = _mm_blend_epi16(b1, b2, 0xF0); \
+	b = _mm_xor_si128(b, a);  \
+} while(0)
+
+#define COMPRESS(v02,v13) \
+	do \
+	{ \
+		HALF_ROUND(v02,v13,13,16); \
+		v02 = _mm_shuffle_epi32(v02, _MM_SHUFFLE(0,1,3,2)); \
+		HALF_ROUND(v02,v13,17,21); \
+		v02 = _mm_shuffle_epi32(v02, _MM_SHUFFLE(0,1,3,2)); \
+	} while(0)
+
+	for(i = 0; i < (n-n%8); i += 8)
+	{
+		mi = _mm_loadl_epi64((__m128i*)(m + i));
+		v13 = _mm_xor_si128(v13, _mm_unpacklo_epi64(zero, mi));
+		for(k = 0; k < SIPHASH_ROUNDS; ++k) COMPRESS(v02,v13);
+		v02 = _mm_xor_si128(v02, mi);
+	}
+
+	mi = _mm_loadl_epi64((__m128i*)(m + i));
+	len = _mm_set_epi32(0, 0, (n&0xff) << 24, 0);
+	mask = _mm_srli_epi64(_mm_set_epi32(0, 0, 0xffffffff, 0xffffffff), 8*(8-n%8));
+	mi = _mm_xor_si128(_mm_and_si128(mi, mask), len);
+
+	v13 = _mm_xor_si128(v13, _mm_unpacklo_epi64(zero, mi));
+	for(k = 0; k < SIPHASH_ROUNDS; ++k) COMPRESS(v02,v13);
+	v02 = _mm_xor_si128(v02, mi);
+	
+	v02 = _mm_xor_si128(v02, _mm_set_epi32(0, 0xff, 0, 0));
+	for(k = 0; k < SIPHASH_FINALROUNDS; ++k) COMPRESS(v02,v13);
+
+	v0 = _mm_xor_si128(v02, v13);
+	v0 = _mm_xor_si128(v0, _mm_castps_si128(_mm_movehl_ps(_mm_castsi128_ps(zero), _mm_castsi128_ps(v0))));
+	hash.xmm = v0;
+
+#undef COMPRESS
+#undef HALF_ROUND
+	//return _mm_extract_epi32(v0, 0) | (((u64)_mm_extract_epi32(v0, 1)) << 32);
+	return hash.gpr;
+}
+
+int crypto_auth(unsigned char *out,const unsigned char *in,unsigned long long inlen,const unsigned char *k)
+{
+  int i;
+  union
+  {
+    u8  bytes[8];
+    u64 gpr;
+  } hash;
+  hash.gpr = siphash(k, in, inlen);
+  for(i=0; i < 8; ++i) out[i] = hash.bytes[i];
+  return 0;
+}
+
+int crypto_auth_verify(const unsigned char *h,const unsigned char *in,unsigned long long inlen,const unsigned char *k)
+{
+  u8 correct[8];
+  crypto_auth(correct,in,inlen,k);
+  return crypto_verify_8(h,correct);
+}
+
+#if 0
+/*
+   SipHash-2-4 output with
+   k = 00 01 02 ...
+   and
+   in = (empty string)
+   in = 00 (1 byte)
+   in = 00 01 (2 bytes)
+   in = 00 01 02 (3 bytes)
+   ...
+   in = 00 01 02 ... 3e (63 bytes)
+*/
+u8 vectors[64][8] =
+{
+  { 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, },
+  { 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, },
+  { 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, },
+  { 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, },
+  { 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, },
+  { 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, },
+  { 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, },
+  { 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, },
+  { 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, },
+  { 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, },
+  { 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, },
+  { 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, },
+  { 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, },
+  { 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, },
+  { 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, },
+  { 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, },
+  { 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, },
+  { 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, },
+  { 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, },
+  { 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, },
+  { 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, },
+  { 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, },
+  { 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, },
+  { 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, },
+  { 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, },
+  { 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, },
+  { 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, },
+  { 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, },
+  { 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, },
+  { 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, },
+  { 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, },
+  { 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, },
+  { 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, },
+  { 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, },
+  { 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, },
+  { 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, },
+  { 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, },
+  { 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, },
+  { 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, },
+  { 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, },
+  { 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, },
+  { 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, },
+  { 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, },
+  { 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, },
+  { 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, },
+  { 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, },
+  { 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, },
+  { 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, },
+  { 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, },
+  { 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, },
+  { 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, },
+  { 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, },
+  { 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, },
+  { 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, },
+  { 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, },
+  { 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, },
+  { 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, },
+  { 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, },
+  { 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, },
+  { 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, },
+  { 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, },
+  { 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, },
+  { 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, },
+  { 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, }
+};
+
+
+int test_vectors()
+{
+#define MAXLEN 64
+  u8 in[MAXLEN], out[8], k[16];
+  int i;
+  int ok = 1;
+
+  for( i = 0; i < 16; ++i ) k[i] = i;
+
+  for( i = 0; i < MAXLEN; ++i )
+  {
+    in[i] = i;
+    crypto_auth( out, in, i, k );
+
+    if ( memcmp( out, vectors[i], 8 ) )
+    {
+      printf( "test vector failed for %d bytes\n", i );
+      ok = 0;
+    }
+  }
+
+  return ok;
+}
+
+int main()
+{
+  if ( test_vectors() ) printf( "test vectors ok\n" );
+
+  return 0;
+}
+
+#endif
+
diff -Nur nacl-20110221.orig/crypto_auth/siphash24/used nacl-20110221/crypto_auth/siphash24/used
--- nacl-20110221.orig/crypto_auth/siphash24/used	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_auth/siphash24/used	2013-07-21 10:37:35.564846194 +0200
@@ -0,0 +1 @@
+
diff -Nur nacl-20110221.orig/crypto_verify/8/checksum nacl-20110221/crypto_verify/8/checksum
--- nacl-20110221.orig/crypto_verify/8/checksum	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_verify/8/checksum	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1 @@
+0
diff -Nur nacl-20110221.orig/crypto_verify/8/ref/api.h nacl-20110221/crypto_verify/8/ref/api.h
--- nacl-20110221.orig/crypto_verify/8/ref/api.h	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_verify/8/ref/api.h	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1 @@
+#define CRYPTO_BYTES 8
diff -Nur nacl-20110221.orig/crypto_verify/8/ref/verify.c nacl-20110221/crypto_verify/8/ref/verify.c
--- nacl-20110221.orig/crypto_verify/8/ref/verify.c	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_verify/8/ref/verify.c	2013-04-20 06:40:24.000000000 +0200
@@ -0,0 +1,16 @@
+#include "crypto_verify.h"
+
+int crypto_verify(const unsigned char *x,const unsigned char *y)
+{
+  unsigned int differentbits = 0;
+#define F(i) differentbits |= x[i] ^ y[i];
+  F(0)
+  F(1)
+  F(2)
+  F(3)
+  F(4)
+  F(5)
+  F(6)
+  F(7)
+  return (1 & ((differentbits - 1) >> 8)) - 1;
+}
diff -Nur nacl-20110221.orig/crypto_verify/8/used nacl-20110221/crypto_verify/8/used
--- nacl-20110221.orig/crypto_verify/8/used	1970-01-01 01:00:00.000000000 +0100
+++ nacl-20110221/crypto_verify/8/used	2013-07-21 10:30:27.100828593 +0200
@@ -0,0 +1 @@
+
